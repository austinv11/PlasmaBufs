#!/usr/bin/env python3
import argparse
import warnings
from datetime import datetime
from subprocess import call
import os
import os.path as osp
from glob import glob
import re


# TODO: Port this to make it more generalized


PROTO_DIR = os.getcwd() if os.getcwd().endswith("proto") else osp.join(os.getcwd(), "proto")
PY_OUTPUT_DIR = osp.join(os.getcwd() if not os.getcwd().endswith("proto") else osp.dirname(os.getcwd()), "tupperware",
                         "payloads")
IMPORT_REGEX = re.compile(r'((?:import )|(?:from ))([^_]+_pb2)')  # Matches import statements of _pb2 files
MESSAGE_REGEX = re.compile(r'(?:(?:message )|(?:enum ))([^ ]+)(?:[ ]*[{])')  # Matches declared types in .proto files


def main(python=True, java=True):
    assert python or java

    if python:
        print("Clearing previous files...")
        for file in glob(osp.join(PY_OUTPUT_DIR, '*_pb2.py')):
            os.remove(file)
        if osp.exists(osp.join(PY_OUTPUT_DIR, '__init__.py')):
            os.remove(osp.join(PY_OUTPUT_DIR, '__init__.py'))
        print("Compiling python files...")
        call(['protoc',
              '-I={}'.format(PROTO_DIR),
              '--python_out={}'.format(PY_OUTPUT_DIR)
              ] + glob(osp.join(PROTO_DIR, '*.proto')))
        print("Working around protoc not accounting for modular import structures...")

        for file in glob(osp.join(PY_OUTPUT_DIR, '*_pb2.py')):
            lines = []
            with open(osp.join(PY_OUTPUT_DIR, file), 'r') as f:
                for line in f:
                    matches = IMPORT_REGEX.findall(line)
                    for _, name in matches:
                        line = line.replace(name, "tupperware.payloads." + name, 1)
                    lines.append(line)

            with open(osp.join(PY_OUTPUT_DIR, file), 'w') as f:
                f.write("\n".join(lines))

        print("Exporting definitions...")
        with open(osp.join(PY_OUTPUT_DIR, '__init__.py'), 'w') as f:
            f.write("# Automatically generated by the Tupperware protobuf build tool, do NOT edit this file!\n")
            f.write("# Generation time: {}\n\n".format(datetime.now()))
            all_collection = {'is_payload_defined'}  # We know this is gonna exist already
            for file in glob(osp.join(PROTO_DIR, '*.proto')):
                with open(osp.join(PROTO_DIR, file), 'r') as f2:
                    f.write("from .{} import ".format(osp.basename(file).replace('.proto', '_pb2')))
                    curr_matches = []
                    for match in MESSAGE_REGEX.findall(f2.read()):
                        all_collection.add(match)
                        curr_matches.append(match)
                    f.write(", ".join(curr_matches) + "\n")
            f.write("\n__all__ = (")
            for all_entry in all_collection:
                f.write('"{}", '.format(all_entry))
            f.write(")\n\n")

            # Mixin function to check that a type is actually a payload type
            f.write("""
def is_payload_defined(type_string: str) -> bool:
    \"\"\"
    Returns true if the passed string matches the name of a defined protobuf payload type.
    \"\"\"
    return type_string != "is_payload_defined" and type_string in __all__
""")
        print("Done!")

    if java:
        warnings.warn("Java not implemented yet!")


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('-j', '--java', default=False, action="store_true", help="Only compile java files.")
    parser.add_argument('-p', '--python', default=False, action="store_true", help="Only compile python files.")
    args = parser.parse_args()
    main(python=not args.java, java=not args.python)
